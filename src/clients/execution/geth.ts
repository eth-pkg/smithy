import { ClientConfig, EthereumConfig } from "@/clients/types";

/**
 * Generate Geth configuration based on the provided Ethereum config
 * @param config The Ethereum configuration
 * @returns Geth configuration as a string
 */
function generateConfig(config: EthereumConfig): string {
  const { commonConfig, executionConfig } = config;

  // This is a dummy implementation - in a real scenario,
  // we would generate a proper TOML/JSON configuration
  return `
# Geth Configuration File
# Generated by Smithy

[Eth]
NetworkId = ${commonConfig.network === "mainnet" ? 1 : 5}
SyncMode = "${commonConfig.syncMode}"
GasPrice = 1000000000
EthDiscoveryURLs = []
SnapDiscoveryURLs = []

[Node]
DataDir = "${commonConfig.dataDir}"
IPCPath = "geth.ipc"

[Node.P2P]
MaxPeers = ${executionConfig.p2p.maxPeers}
NoDiscovery = false
ListenAddr = "0.0.0.0:${executionConfig.p2p.port}"

[Node.HTTPTimeouts]
ReadTimeout = 30000000000
WriteTimeout = 30000000000
IdleTimeout = 120000000000

[Ethash]
CacheDir = "ethash"
CachesInMem = 2
CachesOnDisk = 3
CachesLockMmap = false
DatasetsInMem = 1
DatasetsOnDisk = 2
DatasetsLockMmap = false

[JsonRpc]
HTTPEnabled = ${executionConfig.http.enabled}
HTTPHost = "0.0.0.0"
HTTPPort = ${executionConfig.http.port}
HTTPCors = ["${executionConfig.http.cors.join('", "')}"]
HTTPVirtualHosts = ["*"]
HTTPModules = ["${executionConfig.http.apiPrefixes.join('", "')}"]
WSEnabled = ${executionConfig.ws.enabled}
WSPort = ${executionConfig.ws.port}
WSHost = "0.0.0.0"
WSOrigins = ["*"]
WSModules = ["${executionConfig.http.apiPrefixes.join('", "')}"]

[JsonRpc.JwtSecret]
JwtSecretFile = "${commonConfig.engine.jwtFile}"

[Engine]
EngineEnabled = true
EnginePort = ${commonConfig.engine.apiPort}
EngineHost = "${commonConfig.engine.host}"

[Metrics]
Enabled = ${executionConfig.metrics.enabled}
Port = ${executionConfig.metrics.port}
`;
}

export const client: ClientConfig = {
  name: "Geth",
  type: "execution",
  generateConfig,
};
