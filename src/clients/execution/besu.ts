import { ClientConfig, EthereumConfig } from "@/clients/types";

/**
 * Generate Besu configuration based on the provided Ethereum config
 * @param config The Ethereum configuration
 * @returns Besu configuration as a string
 */
function generateConfig(config: EthereumConfig): string {
  const { commonConfig, executionConfig } = config;

  // This is a dummy implementation - in a real scenario,
  // we would generate a proper TOML configuration
  return `
# Besu Configuration File
# Generated by Smithy

data-path="${commonConfig.dataDir}/besu"
network=${commonConfig.network}

# P2P Settings
p2p-port=${executionConfig.p2p.port}
max-peers=${executionConfig.p2p.maxPeers}
discovery-enabled=true

# Sync and Storage
sync-mode="${commonConfig.syncMode}"
pruning-enabled=true

# JSON-RPC API
rpc-http-enabled=${executionConfig.http.enabled}
rpc-http-host=0.0.0.0
rpc-http-port=${executionConfig.http.port}
rpc-http-cors-origins=["${executionConfig.http.cors.join('", "')}"]
rpc-http-api=["${executionConfig.http.apiPrefixes.join('", "')}"]

# WebSocket API
rpc-ws-enabled=${executionConfig.ws.enabled}
rpc-ws-host=0.0.0.0
rpc-ws-port=${executionConfig.ws.port}
rpc-ws-api=["${executionConfig.http.apiPrefixes.join('", "')}"]

# Engine API
engine-rpc-enabled=true
engine-jwt-secret="${commonConfig.engine.jwtFile}"
engine-host-allowlist=["*"]
engine-rpc-port=${commonConfig.engine.apiPort}

# Metrics
metrics-enabled=${executionConfig.metrics.enabled}
metrics-host=0.0.0.0
metrics-port=${executionConfig.metrics.port}

# Logging
logging="INFO"
`;
}

export const client: ClientConfig = {
  name: "Besu",
  type: "execution",
  generateConfig,
};
