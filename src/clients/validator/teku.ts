import { ClientConfig, EthereumConfig } from "@/clients/types";

/**
 * Generate Teku validator client configuration
 * @param config The Ethereum configuration
 * @returns Teku validator configuration as a string
 */
function generateConfig(config: EthereumConfig): string {
  const { commonConfig, consensusConfig } = config;

  // This is a dummy implementation - in a real scenario,
  // we would generate a proper YAML/TOML configuration
  return `
# Teku Validator Configuration File
# Generated by Smithy

# Note: Teku can run validators in the same process as the beacon node
# This config is for a standalone validator client setup

# Network
network: "${commonConfig.network}"
data-path: "${commonConfig.dataDir}/teku-validator"

# Beacon node
beacon-node-api-endpoint: "http://localhost:${consensusConfig.httpPort}"

# Validator keys
validator-keys: "${commonConfig.dataDir}/teku-validator/keys:/${commonConfig.dataDir}/teku-validator/passwords"

# Metrics
metrics-enabled: ${commonConfig.features.monitoring}
metrics-interface: "0.0.0.0"
metrics-port: 8009
metrics-categories: ["VALIDATOR", "PROCESS"]

# REST API
rest-api-enabled: true
rest-api-interface: "0.0.0.0"
rest-api-port: 5062
rest-api-docs-enabled: true

# Fee recipient for block proposals
validators-proposer-default-fee-recipient: "0x0000000000000000000000000000000000000000"

# Graffiti
validators-graffiti: "Smithy"

# MEV-Boost settings
validators-builder-registration-default-enabled: ${commonConfig.features.mevBoost}
`;
}

export const client: ClientConfig = {
  name: "Teku Validator",
  type: "validator",
  generateConfig,
};
