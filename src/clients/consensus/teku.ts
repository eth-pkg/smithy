import { ClientConfig, EthereumConfig } from "@/clients/types";

/**
 * Generate Teku consensus client configuration
 * @param config The Ethereum configuration
 * @returns Teku configuration as a string
 */
function generateConfig(config: EthereumConfig): string {
  const { commonConfig, consensusConfig } = config;

  // This is a dummy implementation - in a real scenario,
  // we would generate a proper YAML/TOML configuration
  return `
# Teku Configuration File
# Generated by Smithy

# Network
network: "${commonConfig.network}"
data-path: "${commonConfig.dataDir}/teku"
data-storage-mode: "prune"

# P2P
p2p-enabled: true
p2p-interface: "0.0.0.0"
p2p-port: ${consensusConfig.p2pPort}
p2p-discovery-enabled: true
p2p-peer-lower-bound: 64
p2p-peer-upper-bound: 100

# REST API
rest-api-enabled: true
rest-api-interface: "0.0.0.0"
rest-api-port: ${consensusConfig.httpPort}
rest-api-docs-enabled: true
rest-api-cors-origins: ["*"]

# Metrics
metrics-enabled: ${commonConfig.features.monitoring}
metrics-interface: "0.0.0.0"
metrics-port: ${consensusConfig.metricsPort}
metrics-categories: ["BEACON", "LIBP2P", "NETWORK", "PROCESS"]

# Execution layer
ee-endpoint: "${commonConfig.engine.endpointUrl}"
ee-jwt-secret-file: "${commonConfig.engine.jwtFile}"

# Builder API
builder-endpoint: "${commonConfig.features.mevBoost ? "http://localhost:18550" : ""}"
`;
}

export const client: ClientConfig = {
  name: "Teku",
  type: "consensus",
  generateConfig,
};
